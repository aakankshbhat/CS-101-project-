def shared_motif(dna_list):
        motif = '' #will add common letters as they are found
        dna_string = dna_list[-1] #last string in dna_list
        dnastring_len = len(dna_list[-1])+1 #add one for inclusivity purposes
        for i in range(dnastring_len): 
            for k in range((dnastring_len)-(i+1)): #new range taking into account already tested indices
                string = dna_string[i:i+k] # k = change in index value from start to end of shared motif
                for index in dna_list:
                    if all(string in index for index in dna_list) == True: #all function returns true if in string in all indices
                        if k > len(motif): #can't be zero
                            motif = string
                            if all(string in index for index in dna_list) == False: #case with no common substrings
                                motif = ""
        return motif

#inspiration from dynamic programming on wikipedia and algorithms.tutorialhorizon

#inspiration from https://www.programiz.com/python-programming/methods/built-in/all



import math

def perfect_match(rna): 
    number_C = rna.count("C")
    number_G = rna.count("G")
    number_U = rna.count("U")
    number_A = rna.count("A")
    if number_C == number_G: #below if statements find the number of GC and UA pairs
        matches_GC = number_C
    if number_C != number_G:
        matches_GC = 0
    if number_U == number_A: 
        matches_UA = number_U
    if number_C != number_G:
        matches_UA = 0
    if matches_GC and matches_UA != 0:
        number_matches =  (math.factorial(matches_UA)*math.factorial(matches_GC)) 
    else:   #can't use factorial since 0! is equal to one
        number_matches = 0
    return number_matches
        
    #number of perfect matches is equal to matches_UA! * matches_GC!
    


#the reverse_complement function is the same code from milestone 1
#finding the complement string of a given DNA string
def reverse_complement(dna):
    #reverse dna string
    dna_reverse = dna[::-1]
    dna_complement = ''
    #each letter in the reverse string is replaced with complement letter
    #all is added to a new string (dna_complement)
    for symbol in dna_reverse:
        if symbol == 'A':
            dna_complement += 'T'
        elif symbol == 'T':
            dna_complement += 'A'
        elif symbol == 'C':
            dna_complement += 'G'
        else:
            dna_complement += 'C'
    return dna_complement

#finds out if a sub-string in DNA is a reverse palindrome
def rev_palindrome(dna):
    palindromes= []
    for n in range(len(dna)): #the starting position must be within the DNA string
        for i in range(4,13): #the length of the tuple must be between 4 and 12
            #a starting position of 3 before the end of the string cannot produce tuple with minimum of 4 letters
            if n == (len(dna)-3):
                break
            #the starting position plus the length of the sub-string cannot be longer than the entire length of the DNA string
            if (n+i) > len(dna):
                break
            dna_pal= dna[n:(n+i)] #DNA substring
            rev_comp_pal= reverse_complement(dna_pal) #reverse complement to DNA substring
            #if both the DNA substring and reverse complement are the same, they are reverse palindromes
            if dna_pal == rev_comp_pal:
                position= n
                length= i
                palindromes.append((position,length))
    return palindromes
