def find_splice(dna_motif, dna):
    #Function takes in two strings
    index_list = []
    list_characters = []
    for letter in dna_motif:
        list_characters.append(letter) #Creates a list of letters needed
    for count in range(len(list_characters)):
        element = list_characters[count]
        index = dna.index(element)
        dna = dna[index:] #Restructure the string to beyond the index that we just checked
        if count == 0:
            index_list.append(index) #Index of the first is the normal index
        else:
            index_list.append(index + index_list[count-1]) #Index of subsequent strings is influenced by the substring being created
    return index_list
    
def shared_motif(dna_list):
        motif = '' #will add common letters as they are found
        dna_string = dna_list[-1] #last string in dna_list
        dnastring_len = len(dna_list[-1])+1 #add one for inclusivity purposes
        for i in range(dnastring_len): 
            for k in range((dnastring_len)-(i+1)): #new range taking into account already tested indices
                string = dna_string[i:i+k] # k = change in index value from start to end of shared motif
                for index in dna_list:
                    if all(string in index for index in dna_list) == True: #all function returns true if in string in all indices
                        if k > len(motif): #can't be zero
                            motif = string
                            if all(string in index for index in dna_list) == False: #case with no common substrings
                                motif = ""
        return motif

#inspiration from dynamic programming on wikipedia and algorithms.tutorialhorizon

#inspiration from https://www.programiz.com/python-programming/methods/built-in/all

dict={}
def get_edges(dict):
        key_list = dict.keys()
        list=[]
        for i in key_list:
            list.append(i)
        list2=[]
        for i in range(0,len(list)):
            for j in range(0,len(list)):
                
                if i==j:
                    break
                if(dict[list[i]][:3]==dict[list[j]][-3:]):
                    list2.append((list[j],list[i]))  
                if (dict[list[i]][-3:]==dict[list[j]][:3]):
                    list2.append((list[i],list[j]))
        return list2

adjencey_list=get_edges(dict)
print(adjencey_list)

def assemble_genome(dna_list):
    list_of_possibilities = []
    shortest_string = []
    for string in dna_list:
        go_to_next_string = False
        if len(dna_list) == 1:
            shortest_string.append(string)
            break
        for i in range(len(string)):
            if i == 0:
                shortest_string.append(string[i])
                continue
            if i == len(string):
                shortest_string.append(string[i])
                break
            count = 0
            gone_through_loop = False
            for element in dna_list:
                if element == string:
                    count = count + 1
                    continue
                if string[i] == element[0]:
                    print(string[i:])
                    if string[i:] in element == True: #########################this is the line, I want to check if a splice is in the section, I thought this line was write but I realised it only works for lists and not strings
                        shortest_string.append(string[i:])
                        for j in range(len(dna_list)):
                            if dna_list[j] == element:
                                dna_list[j] = dna_list[j][i:]
                    go_to_next_string = True
                    dna_list.remove(string)
                    break
                count = count + 1
                if count == 4:
                    gone_through_loop = True
            if gone_through_loop == True:
                shortest_string.append(string[i])
            if go_to_next_string == True:
                break
    shortest_string = "".join(shortest_string)
    return shortest_string
    
import math

def perfect_match(rna): 
    number_C = rna.count("C")
    number_G = rna.count("G")
    number_U = rna.count("U")
    number_A = rna.count("A")
    if number_C == number_G: #below if statements find the number of GC and UA pairs
        matches_GC = number_C
    if number_C != number_G:
        matches_GC = 0
    if number_U == number_A: 
        matches_UA = number_U
    if number_C != number_G:
        matches_UA = 0
    if matches_GC and matches_UA != 0:
        number_matches =  (math.factorial(matches_UA)*math.factorial(matches_GC)) 
    else:   #can't use factorial since 0! is equal to one
        number_matches = 0
    return number_matches
        
    #number of perfect matches is equal to matches_UA! * matches_GC!
   
 dna=""
 gc_content=[]
 def random_genome(dna, gc_content):
    dna = dna.upper()
    cg = len(dna.replace('A', '').replace('T', ''))
    at = len(dna.replace('C', '').replace('G', ''))
    result= []
    for i in range(0, len(gc_content)):
        prob = cg * math.log10(float(gc_content[i]) / 2) + at * math.log10((1 - float(gc_content[i])) / 2)
        result.append(round(prob, 3))
    return result
a=random_genome(dna,gc_content)
print(a)

#the reverse_complement function is the same code from milestone 1
#finding the complement string of a given DNA string
def reverse_complement(dna):
    #reverse dna string
    dna_reverse = dna[::-1]
    dna_complement = ''
    #each letter in the reverse string is replaced with complement letter
    #all is added to a new string (dna_complement)
    for symbol in dna_reverse:
        if symbol == 'A':
            dna_complement += 'T'
        elif symbol == 'T':
            dna_complement += 'A'
        elif symbol == 'C':
            dna_complement += 'G'
        else:
            dna_complement += 'C'
    return dna_complement

#finds out if a sub-string in DNA is a reverse palindrome
def rev_palindrome(dna):
    palindromes= []
    for n in range(len(dna)): #the starting position must be within the DNA string
        for i in range(4,13): #the length of the tuple must be between 4 and 12
            #a starting position of 3 before the end of the string cannot produce tuple with minimum of 4 letters
            if n == (len(dna)-3):
                break
            #the starting position plus the length of the sub-string cannot be longer than the entire length of the DNA string
            if (n+i) > len(dna):
                break
            dna_pal= dna[n:(n+i)] #DNA substring
            rev_comp_pal= reverse_complement(dna_pal) #reverse complement to DNA substring
            #if both the DNA substring and reverse complement are the same, they are reverse palindromes
            if dna_pal == rev_comp_pal:
                position= n
                length= i
                palindromes.append((position,length))
    return palindromes
